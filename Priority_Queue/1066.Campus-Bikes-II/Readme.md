### 1066.Campus-Bikes-II

此题本质上并没有特别高效的解法，应该是一个NP问题。也就是说，每个人还是需要把所有的自行车都试一遍才行。不过还是有贪心的思想能够加快搜索到结果。

我们设计一个队列，每个队列中的存储的“状态”包括三个变量```{cost,i,taken}```.其中i表示我们正要处理第i个工人的配对（但还没有完成），cost表示处理完之前i-1个工人的人车配对之和，taken是一个状态压缩整数，其中每个bit位表示该自行车是否已经被选取。

我们将这个队列始终按照cost从小到大有序。因此可以用优先队列的数据结构，有序set也行。我们每弹出一个状态，都会在此状态的基础上，给第i个工人尝试配对所有可用的自行车（已经在taken中被标记已经使用过的除外），然后更新cost再放入队列中。注意到队列按照cost排序，所以优先弹出的永远是cost最小的，这个贪心策略是合理的。一旦弹出的状态的i表示已经处理完了所有的工人，那么它一定是完成所有配对的最优方案！剩下的所有的状态就可以忽略掉。

此外，我们还需要有一个visited的集合来记录已经访问过的```{i,taken}```。因为我们总是优先处理cost最小的状态，所以如果遇到已经处理过的```{i,taken}```，肯定不是最优解，一定可以忽略。


[Leetcode Link](https://leetcode.com/problems/campus-bikes-ii)