### 1392.Longest-Happy-Prefix

这道题所求的东西其实就是KMP算法中的一个重要的步骤，称为求后缀数组。我们先来回顾一下后缀数组在KMP中的应用。

我们令长字符串为s，目标字符串为t。后缀数组suffix[j]指的是：以其t[j]为尾字符的最长的后缀子串，恰好同时满足它是t的前缀。也就是说，如果suffix[j-1]==k的话，那么t[0:k-1]==t[j-k:j-1]。注意，这里的k可以是零。

下面举个例子。我们在如下的位置尝试将t[0]与s[i-4]对齐进行匹配。结果发现最多只能匹配到t[4]==s[i]，当查到t[5]!=s[i+1]时匹配失败。
```
          i
s:bacbababaabcbab
      |||||
t:    abababca
      012345
```    
这时候是否意味着我们只能将t[0]重新与s[i-3]对齐然后再匹配呢？其实不用。我们如果查到suffix[4]=3的话（结合上面的定义，这个前缀与后缀的共同子串就是"aba"），我们知道s[i-2:i]==t[0:2]，于是下一步我们可以直接将s[i-2]和t[0]对齐，而且这个对齐必定能保证3个字符的匹配，意味着下一次我们只要查看s[i+1]是否和t[3]相等就行了。（见下图）
```
          i
s:bacbababaabcbab
        |||
t:      abababca
        012345
```    
总结一下，我们从s[i+1]!=t[j+1]时的匹配失败，可以跳转的下一步是检查s[i+1]是否能和t[suffix[j]]匹配，而不必重头检查s的下一个字符与t[0]开始匹配。这中间优化的一步就是充分利用了后缀数组的作用：已知当前s[i-j:i]==t[0:j]，而且t[j]结尾的长度为k（即suffix[j]）的子串恰好是t的前缀，所以我们立即得知s[i-k+1:i]（即以s[i]为结尾的长度为k的子串）与t[0:k-1]（即t的长度为k的前缀串）已经是匹配的了。

====================

接下来我们正式研究如何求这个后缀数组suffix。再次明确一下，对于目标串t，suffix[j]=k表示以j为结尾、长度为k的子串恰好就是t的前缀。这就意味着t[k-1]==t[j]. (注意k可以是零)

假设我们考虑已经考察完了数组t中的前j-1个数。令i=suffix[j-1]，可以知道前缀t[0:i-1]和后缀t[j-i:j-1]是完全匹配的（长度是i）, 其中各自的尾元素t[i-1]和t[j-1]是对齐的。此时我们考虑t[i]和t[j]的比较。

1. 如果t[i]==t[j]，那么说明这个匹配的前缀和后缀都可以进一步延长，所以 suffix[j] = suffix[j-1]+1.

2. 如果t[i]!=t[j]，我们会查看i'=suffix[i-1]。注意根据后缀数组的定义，说明前缀t[0:i'-1]和后缀t[i-i':i-1]是完全匹配的（长度是i'）。此时，我们再利用之前的结论：前缀t[0:i-1]和后缀t[j-i:j-1]是完全匹配的（长度是i）。这两点综合起来：说明前缀t[0:i'-1]和后缀t[j-i':j-1]是完全匹配的（长度是i'）！我们可以通过下面这张图来分析：
```
    A
0 ##### (i'-1)           (i-1)
-------------------------
                     C

                     B
                    #####
                    ------------------------------(j-1)
                                              D
```
推导：因为前缀t[0:i-1]等于后缀t[j-i:j-1]，所以区间C==区间D。因为前缀t[0:i'-1]等于后缀t[i-i':i-1]，所以区间A==区间B。因为区间C和区间B是同一段，所以有区间A与区间D相等。即得出结论：前缀t[0:i'-1]和后缀t[j-i':j-1]是完全匹配的。

此时各自的尾元素t[i'-1]和t[j-1]是对齐的，就自然引导我们继续做t[i']和t[j]的比较。如果相等，那么说明suffix[j]是在i'的基础上加1，返回答案。如果不等，那么就重复步骤2, 查看i'' = suffix[i'-1]，找一个更短的前缀，这个前缀同样也应该是以t[j-1]为末尾的后缀。依次类推i'''，直至这样的i==0为止，说明t[j]其实无法与s中的任何一个元素相等。因此赋值suffix[j]=0.

代码组织如下：
```cpp
        for (int j=1; j<n; j++)
        {
            while (i>0 && s[i]!=s[j])
                i = suffix[i-1];
            
            if (s[i]==s[j])
            {
                suffix[j] = i+1;
                i++;
            }                
        }
```        
特别注意suffix[0]=0（因为不能包括自身）并且循环从index为1的元素开始。
